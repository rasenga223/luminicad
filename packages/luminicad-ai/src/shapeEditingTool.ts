import { AiCadExecutionService } from "luminicad-ai";
import {
    IApplication,
    IDocument,
    INode,
    INodeLinkedList,
    Logger,
    PubSub,
    Result,
    ShapeNode,
} from "luminicad-core";

function findNode(doc: IDocument, identifier: string): INode | null {
    let foundNodeById: INode | null = null;
    let foundNodesByName: INode[] = [];

    function traverse(node: INode | null) {
        if (!node) {
            return;
        }

        if (node.id === identifier) {
            foundNodeById = node;
            return;
        }

        if (node.name === identifier) {
            foundNodesByName.push(node);
        }

        if (foundNodeById) return;

        if ("firstChild" in node && typeof (node as any).firstChild !== "undefined") {
            const linkedListNode = node as INodeLinkedList;
            let currentChildNode: INode | null = linkedListNode.firstChild || null;
            while (currentChildNode && !foundNodeById) {
                traverse(currentChildNode);
                currentChildNode = (currentChildNode as any).nextSibling || null;
            }
        }
    }

    traverse(doc.rootNode);

    if (foundNodeById) {
        Logger.info(`findNode: Found node by ID: "${identifier}"`);
        return foundNodeById;
    }

    if (foundNodesByName.length > 0) {
        if (foundNodesByName.length > 1) {
            Logger.warn(
                `findNode: Multiple nodes found with name "${identifier}". Returning the first one. Consider using unique IDs for precision.`,
            );
        }
        Logger.info(`findNode: Found node(s) by name: "${identifier}". Returning first match.`);
        return foundNodesByName[0];
    }

    Logger.warn(`findNode: No node found with ID or name: "${identifier}"`);
    return null;
}

/**
 * ShapeEditingTool provides methods for an AI agent to manipulate shapes
 * within a LuminiCAD document, such as deleting or editing them.
 */
export class ShapeEditingTool {
    /**
     * Deletes a shape (node) from the document by its ID or name.
     * @param identifier The unique ID or name of the shape/node to delete.
     * @param app The IApplication instance.
     * @returns A Result object indicating success (with a message) or failure (with an error message).
     */
    public static async deleteShape(identifier: string, app: IApplication): Promise<Result<string, string>> {
        const document = app.activeView?.document;
        if (!document) {
            Logger.warn("ShapeEditingTool.deleteShape: No active document found.");
            return Result.err("No active document found to delete shape from.");
        }

        const nodeToDelete = findNode(document, identifier);
        if (!nodeToDelete) {
            Logger.warn(`ShapeEditingTool.deleteShape: Node with identifier "${identifier}" not found.`);
            return Result.err(`Node with identifier "${identifier}" not found.`);
        }

        if (document.currentNode && document.currentNode.id === nodeToDelete.id) {
            document.currentNode = document.rootNode;
        }

        const parentNode = nodeToDelete.parent as INodeLinkedList | null;
        if (parentNode && "remove" in parentNode && typeof parentNode.remove === "function") {
            parentNode.remove(nodeToDelete);
            Logger.info(
                `ShapeEditingTool.deleteShape: Successfully removed node "${nodeToDelete.name}" (ID/Name: ${identifier}).`,
            );

            document.visual.update();
            PubSub.default.pub("showToast", "toast.delete{0}Objects", 1);
            return Result.ok(`Shape with identifier "${identifier}" deleted successfully.`);
        } else if (!parentNode) {
            Logger.error(
                `ShapeEditingTool.deleteShape: Node "${nodeToDelete.name}" (Identifier: ${identifier}) is the root node or has no parent. Cannot delete root node this way.`,
            );
            return Result.err(
                `Node with identifier "${identifier}" is the root node or has no parent and cannot be deleted.`,
            );
        } else {
            Logger.error(
                `ShapeEditingTool.deleteShape: Node "${nodeToDelete.name}" (Identifier: ${identifier}) parent does not support remove operation.`,
            );
            return Result.err(`Parent of node with identifier "${identifier}" does not support removal.`);
        }
    }

    /**
     * Edits a shape by deleting the existing one and creating a new one based on CadQuery instructions.
     * The new shape is generated by the AiCadExecutionService with a retry mechanism.
     * @param identifier The unique ID or name of the shape/node to be replaced.
     * @param cadQueryJsonString A JSON string representing the CadQuery task to generate the new shape.
     * @param app The IApplication instance.
     * @returns A Result object containing information about the new node (ID, name) on success,
     *          or an error message on failure.
     */
    public static async editShape(
        identifier: string,
        cadQueryJsonString: string,
        app: IApplication,
    ): Promise<Result<{ newNodeId: string; newNodeName: string; message: string }, string>> {
        let aiService: AiCadExecutionService | undefined;
        if (Array.isArray(app.services)) {
            aiService = app.services.find((s) => s instanceof AiCadExecutionService) as
                | AiCadExecutionService
                | undefined;
        } else if (app.services && typeof (app.services as any).get === "function") {
            aiService = (app.services as any).get(AiCadExecutionService) as
                | AiCadExecutionService
                | undefined;
        }

        if (!aiService) {
            Logger.error(
                "ShapeEditingTool.editShape: AiCadExecutionService not found or app.services structure is unexpected.",
            );
            return Result.err(
                "AiCadExecutionService not available or app.services structure is unexpected.",
            );
        }

        const document = app.activeView?.document;
        if (!document) {
            Logger.warn("ShapeEditingTool.editShape: No active document found.");
            return Result.err("No active document found to edit shape in.");
        }

        const nodeToEdit = findNode(document, identifier);
        if (!nodeToEdit) {
            Logger.error(
                `ShapeEditingTool.editShape: Failed to find node with identifier "${identifier}" to get its ID.`,
            );
            return Result.err(`Failed to find existing shape with identifier "${identifier}".`);
        }
        const actualShapeId = nodeToEdit.id;
        const originalNodeName = nodeToEdit.name;

        Logger.info(
            `ShapeEditingTool.editShape: Attempting to delete old shape with ID "${actualShapeId}" (referred to as "${identifier}").`,
        );
        const deleteResult = await ShapeEditingTool.deleteShape(actualShapeId, app); // Use actualShapeId for delete
        if (!deleteResult.isOk) {
            Logger.error(
                `ShapeEditingTool.editShape: Failed to delete old shape ID "${actualShapeId}" (referred to as "${identifier}"): ${deleteResult.error}`,
            );
            return Result.err(
                `Failed to delete existing shape (ID: ${actualShapeId}): ${deleteResult.error}`,
            );
        }
        Logger.info(
            `ShapeEditingTool.editShape: Successfully deleted old shape ID "${actualShapeId}" (referred to as "${identifier}").`,
        );

        Logger.info(
            "ShapeEditingTool.editShape: Attempting to create new shape via AiCadExecutionService with retries.",
        );
        let creationResult: Result<any, string> | undefined;
        let attempts = 0;
        const maxAttempts = 5;
        let lastError: string =
            "Max attempts reached for shape creation without explicit success or failure.";

        while (attempts < maxAttempts) {
            attempts++;
            Logger.info(
                `ShapeEditingTool.editShape: Attempt ${attempts}/${maxAttempts} to create new shape using CadQuery string: ${cadQueryJsonString.substring(0, 100)}...`,
            );
            try {
                creationResult = await aiService.executeCode(cadQueryJsonString);

                if (creationResult.isOk) {
                    const executionOutput = creationResult.value;
                    if (
                        executionOutput &&
                        executionOutput.node &&
                        executionOutput.node instanceof ShapeNode
                    ) {
                        const newNode = executionOutput.node as ShapeNode;
                        Logger.info(
                            `ShapeEditingTool.editShape: New shape created successfully on attempt ${attempts}. Name: "${newNode.name}", ID: "${newNode.id}". Replaced "${originalNodeName}" (ID: "${actualShapeId}").`,
                        );
                        return Result.ok({
                            newNodeId: newNode.id,
                            newNodeName: newNode.name,
                            message: `Shape identified by "${identifier}" (Name: "${originalNodeName}", ID: "${actualShapeId}") replaced with new shape "${newNode.name}" (ID: ${newNode.id}) after ${attempts} attempt(s).`,
                        });
                    } else {
                        lastError = `AiCadExecutionService executed on attempt ${attempts} but did not return a valid new shape node.`;
                        Logger.error(`ShapeEditingTool.editShape: ${lastError}`, executionOutput);
                        return Result.err(lastError);
                    }
                } else {
                    lastError = `AiCadExecutionService failed on attempt ${attempts}: ${creationResult.error}`;
                    Logger.warn(`ShapeEditingTool.editShape: ${lastError}`);
                    if (attempts < maxAttempts) {
                        Logger.info(
                            "ShapeEditingTool.editShape: Will retry after a short pause if attempts remain.",
                        );
                    }
                }
            } catch (error: any) {
                lastError = `Exception during new shape creation on attempt ${attempts}: ${error.message || error}`;
                Logger.error(`ShapeEditingTool.editShape: ${lastError}`, error);
                // if (attempts < maxAttempts) { await new Promise(resolve => setTimeout(resolve, 1000)); }
            }
        }

        Logger.error(
            `ShapeEditingTool.editShape: All ${maxAttempts} attempts to create new shape failed. Last error: ${lastError}`,
        );
        return Result.err(lastError);
    }
}

export const deleteShapeToolSchema = {
    type: "function" as const,
    function: {
        name: "deleteShape",
        description:
            "Deletes a shape node from the document using its ID or name. Returns a success or error message.",
        parameters: {
            type: "object" as const,
            properties: {
                identifier: {
                    type: "string" as const,
                    description: "The ID or unique name of the shape node to delete.",
                },
            },
            required: ["identifier"],
        },
    },
};

export const editShapeToolSchema = {
    type: "function" as const,
    function: {
        name: "editShape",
        description:
            "Edits an existing shape node by deleting it and then recreating it based on a new CadQuery JSON definition. The shape is identified by its ID or name. Returns a success or error message, or the new node ID on success.",
        parameters: {
            type: "object" as const,
            properties: {
                identifier: {
                    type: "string" as const,
                    description: "The ID or unique name of the shape node to be edited.",
                },
                cadQueryJsonString: {
                    type: "string" as const,
                    description:
                        "A JSON string representing the new CadQuery definition for the shape. This JSON must follow the format expected by the AiCadExecutionService, typically including a 'tool': 'cadquery' directive and the CadQuery script content as a string.",
                },
            },
            required: ["identifier", "cadQueryJsonString"],
        },
    },
};
